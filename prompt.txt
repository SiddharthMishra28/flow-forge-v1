---

# üöÄ Instructions for AI Coding Agent

**Goal**: Generate a **Spring Boot 3.x production-ready backend** for an **End-to-End Test Automation Pipeline Orchestration Platform** that integrates **GitLab Pipelines** and **SquashTM**, supports **runtime test data ingestion**, and executes **flows asynchronously** while persisting state.

---

## üìÇ Project Scope

* Framework: **Java + Spring Boot 3.x**
* Layers:

  * **Models (Entities)**
  * **DTOs**
  * **Repositories (JPA)**
  * **Services**
  * **Controllers (REST APIs)**
  * **Utilities (GitLab API client, output.env parser, async execution handling)**
* Database:

  * **H2** for local development/debug
  * **Postgres** for production
* Execution:

  * **Async** with `CompletableFuture` + ThreadPool Task Executor
  * **Polling + Persistence** of Flow/Execution/Status until conclusion
* Documentation:

  * **Swagger OpenAPI Specs**
  * **README.md for beginners**

---

## üèó Data Model

### 1. **Application**

Represents a GitLab project.
**Fields**:

* `id` (Auto-generated)
* `gitlabProjectId` (String/Long)
* `personalAccessToken` (String)
* `createdAt` / `updatedAt` (Timestamps)

---

### 2. **FlowStep**

Represents a step in a test automation flow.
**Fields**:

* `id` (Auto-generated)
* `applicationId` (FK ‚Üí Application.id)
* `branch` (String)
* `testTag` (String ‚Üí Maven runtime selector)
* `squashStepIds` (List<Long>)
* `initialTestData` (Map\<String, String>) ‚Üí credentials, txn data, etc.
* `createdAt` / `updatedAt` (Timestamps)

---

### 3. **Flow**

Defines an orchestrated sequence of flow steps.
**Fields**:

* `id` (Auto-generated)
* `flowStepIds` (List<Long> ordered ‚Üí sequential execution)
* `squashTestCaseId` (Long)
* `globalVariables` (Map\<String, String>) ‚Üí flow-wide constants injected into all pipelines
* `createdAt` / `updatedAt` (Timestamps)

---

### 4. **FlowExecution**

Represents an instance of flow execution.
**Fields**:

* `id` (UUID, immutable)
* `flowId` (FK ‚Üí Flow\.id)
* `startTime` / `endTime`
* `globalVariables` (Map\<String, String>)
* `runtimeVariables` (Map\<String, String>) ‚Üí merged from each `output.env` across pipelines
* `status` (Enum: PASSED / FAILED)
* `createdAt` (immutable)

---

### 5. **PipelineExecution**

Represents a GitLab pipeline execution inside a flow.
**Fields**:

* `id` (Auto-generated)
* `flowId` (FK ‚Üí Flow\.id)
* `flowExecutionId` (FK ‚Üí FlowExecution.uuid)
* `flowStepId` (FK ‚Üí FlowStep.id)
* `pipelineId` (Long, from GitLab API)
* `pipelineUrl` (String, from GitLab API)
* `startTime` / `endTime`
* `initialTestData` (Map\<String, String>)
* `runtimeTestData` (Map\<String, String>, null if first step)
* `status` (Enum: PASSED / FAILED / CANCELLED)
* `createdAt` (immutable)

---

## üåê API Endpoints

### 1. Applications

* `POST /api/applications` ‚Üí Create
* `GET /api/applications/{id}` ‚Üí Read
* `PUT /api/applications/{id}` ‚Üí Update
* `DELETE /api/applications/{id}` ‚Üí Delete

---

### 2. Flow Steps

* `POST /api/flow-steps` ‚Üí Create
* `GET /api/flow-steps/{id}` ‚Üí Read
* `PUT /api/flow-steps/{id}` ‚Üí Update
* `DELETE /api/flow-steps/{id}` ‚Üí Delete

---

### 3. Flows

* `POST /api/flows` ‚Üí Create flow
* `GET /api/flows/{id}` ‚Üí Get flow details
* `PUT /api/flows/{id}` ‚Üí Update
* `DELETE /api/flows/{id}` ‚Üí Delete

---

### 4. Flow Executions

* `POST /api/flows/{flowId}/execute` ‚Üí Trigger a new flow execution
* `GET /api/flow-executions/{flowExecutionUUID}` ‚Üí Get flow execution summary with nested:

  * Flow details
  * FlowSteps + Applications
  * PipelineExecutions with full metadata

---

### 5. Pipeline Executions

* `GET /api/flow-executions/{flowExecutionUUID}/pipelines` ‚Üí List all pipelines for a flow execution
* `GET /api/flow-executions/{flowExecutionUUID}/pipelines/{pipelineId}` ‚Üí Get details for a single pipeline execution

---

## ‚öôÔ∏è Utilities

1. **GitLab REST API Client**

   * Trigger pipeline execution
   * Poll pipeline status until completion
   * Fetch artifacts (esp. `output.env`)

2. **Output.env Parser**

   * Read GitLab artifact `output.env`
   * Parse into `Map<String, String>`
   * Merge with existing runtime variables

3. **Async Execution Service**

   * Use `CompletableFuture` + `@Async`
   * Execute pipelines sequentially **per flow** but flows run in parallel
   * Poll GitLab APIs until pipeline finishes
   * Update status in DB at each step

---

## üõ† Execution Behavior

* Flows run **asynchronously** but steps inside a flow execute **sequentially**.
* After each step finishes:

  * Read artifacts ‚Üí parse `output.env`
  * Merge runtime variables ‚Üí pass to next step
* Execution persists until:

  * **All steps PASSED ‚Üí Flow = PASSED**
  * **Any step FAILED ‚Üí Flow = FAILED**
  * **User cancels ‚Üí Flow = CANCELLED**

---

## üîë Spring Profiles

1. **Local Dev**

   * H2 in-memory DB
   * Swagger enabled
   * Debug logging

2. **Production**

   * PostgreSQL
   * Optimized async threadpool config

---

## üìñ Documentation

1. **Swagger/OpenAPI 3.x** auto-generated for all endpoints.
2. **README.md** for **absolute beginners**:

   * Step-by-step setup (local + prod)
   * How to configure Application, FlowStep, Flow
   * How to execute a Flow and track results
   * Example API calls (with `curl`/Postman)
   * Example of parsing `output.env`

---

‚úÖ With the above structure, the AI coding agent can generate a **full working Spring Boot 3.x project** with **no compilation errors**, **async GitLab orchestration**, **runtime data ingestion**, and **production-grade performance**.

---
